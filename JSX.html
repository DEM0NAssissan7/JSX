<!DOCTYPE html>
<!-- JSX: Javascript UNIX

Highlights:
 - Kernel with advanced features like scheduling, suspension, filesystem, graphics pipeline, and more
 - Fully functional command line
 - Unified userland
 - Separate userspace and kernel space
 - UNIX-like commands, such as touch, ls, cd, sleep(), exit(), and system()




















!-->

<html>

<head>
    <meta charset="utf-8">
    <title>JSX</title>

    <!-- Filesystem Initialization -->
    <script>
        let initial_filesystem = [];
        let create_file = function (path, data) {
            if (data)
                initial_filesystem.push([path, data]);
            else
                initial_filesystem.push([path]);
        }

        /* How to create a file using plain text 
        
            1. Push a new array to initial_filesystem specifying the path in the first element
            2. If the file is not a directory, put data in the second element
        */

        // Basic UNIX filesystem initialization
        create_file("/bin");
        create_file("/root");
        create_file("/home");
        create_file("/opt");

        create_file("/usr");
        create_file("/usr/bin");
        create_file("/usr/lib");

        create_file("/etc");
        create_file("/etc/init.d");

        create_file("/lib");
        create_file("/lib/drivers");

        // Fstab (for mounting the root filesystem)
        create_file("/etc/fstab", "mount=/,device=/dev/disk0");

        // Init system
        create_file("/run");
        create_file("/run/log");
        create_file("/run/log/journal", "");
        create_file("/bin/init", function () {
            this.main = function () {
                chdir("/etc/init.d");
                let files = readdir(".");
                for (let i = 0; i < files.length; i++)
                    exec(files[i]);
                exit();
            }
        });
    </script>

    <!-- Userland -->
    <script>
        {
            // Shell
            create_file("/bin/sh", function () {

            });
        }

    </script>

    <!-- Drivers -->
    <script>
        /* The goal of drivers are to 
            1. Map devices to files
            2. Deal with edge cases
        */
        create_file("/etc/init.d/mouse", function () {
            let struct = {
                vectorX: 0,
                vectorY: 0,
                x: 0,
                y: 0,
                pressed: 0
            };
            fopen("/dev/mouse0", "w", struct);
            document.onmousemove = function (event) {
                struct.vectorX = struct.x - event.pageX + 8;
                struct.vectorY = struct.y - event.pageY + 8;
                struct.x = event.pageX - 8;
                struct.y = event.pageY - 8;
            };
            document.onmousedown = function() {
                struct.clicked = true;
            };
            document.onmouseup = function() {
                struct.clicked = false;
            };
            this.main = function () {
                exit();
            }

        });
    </script>

    <!-- Library Functions -->
    <script>
        function deep_obj(object) {
            // return JSON.parse(JSON.stringify(object));
            return object;
        }

        {
            let time = performance.now();
            function get_time() {
                return performance.now() - time;
            }
        }
    </script>

    <!-- Kernel -->
    <script>
        create_file = undefined;
        let user_eval = function (code) {
            eval(code);
        }
        {
            // Uname
            let utsname = {
                system: "JSX",
                release: "0.01",
            }
            function uname() {
                return deep_obj(utsname);
            }

            // Users
            let users = [];
            let c_user = 0;
            let uids = 0;
            let gids = 0;
            function setuid(uid) {
                if (c_process.user === 0)
                    c_process.user = uid;
            }

            // Processes
            let processes = [];
            let c_process = {};
            let c_thread = {};
            let pids = 0;
            let Thread = function (code, process) {
                this.exec = new code(); // Create an object from the pass-in code
                this.last_execution = get_time();
                this.queued = false;
                this.sleep_time = 0;
                this.pid = pids++;
                this.process = process;
                this.dead = false;
            }
            let Process = function (code) {
                this.working_directory = "/";
                this.working_directory_inode = 0;
                this.pid = pids;
                this.threads = [];
                this.user = 0;

                this.threads.push(new Thread(code, this));
            }

            // Filesystem
            let file_descriptors = [];
            let mountpoints = [];
            let mountids = 0;
            let VFile = function (path, data, filetype, inode) {
                this.inode = inode;
                this.path = path;
                let filename = "";
                for (let i = 0; i < path.length; i++) {
                    let char = path[i];
                    if (char === "/") {
                        filename = "";
                        continue;
                    }
                    filename += char;
                }
                this.filename = filename;
                this.data = data;
                this.filetype = filetype;
                this.owner = c_user;
                this.permissions = 664;
                this.is_mountpoint = false;
            }
            let Filesystem = function () {
                this.path = "/";
                let file = new VFile("/", [], "d", 0);
                file.is_mountpoint = true;
                this.files = [file];
                this.inodes = 1;
                this.mountid = null;
            }
            let create_fs = function() {
                return new Filesystem();
            }
            function mkfs (device) {
                let file = get_file(device);
                if(file.filetype !== "-") throw new Error("Filesystems can only be created using normal devices");
                get_file(device).file.data = new Filesystem();
            }
            let map_path_names = function (path) {
                let file_string = "";
                let string_list = [];
                for (let i = 0; i < path.length; i++) {
                    let char = path[i];
                    switch (char) {
                        case "/":
                            if (file_string.length !== 0)
                                string_list.push(file_string);
                            file_string = "";
                            continue;
                            break;
                        case ".":
                            if (i === path.length - 1) continue;
                            switch (path[i + 1]) {
                                case ".":
                                    if (path[i + 2] === "/") {
                                        string_list.splice(string_list.length - 1, 1);
                                        i += 2;
                                    }
                                    break;
                                case "/":
                                    i++;
                                    continue;
                                    break;
                            }
                            break;
                    }
                    file_string += char;
                }
                if (file_string.length !== 0)
                    string_list.push(file_string);
                return string_list;
            }
            let expand_filepath = function (path) {
                let prefix = c_process.working_directory;
                if (path[0] === "/" || !prefix)
                    prefix = [];

                let prefix_path_strings = map_path_names(prefix);
                let input_path_strings = map_path_names(path);

                let string = "";
                for (let i = 0; i < prefix_path_strings.length; i++)
                    string += "/" + prefix_path_strings[i];
                for (let i = 0; i < input_path_strings.length; i++)
                    string += "/" + input_path_strings[i];

                return string;
            }
            Filesystem.prototype.create_file = function(path, data, filetype) {
                let path_names = map_path_names(expand_filepath(path));
                let inode = 0;
                let file = this.files[0];
                let parent = this.files[0];
                for (let i = 0; i < path_names.length; i++) {
                    let directory = this.files[inode];
                    let success = false;
                    for (let j = 0; j < directory.data.length; j++) {
                        let child_file = this.files[directory.data[j]];
                        if (child_file.filename === path_names[i]) {
                            success = true;
                            if (child_file.mountpoint === true)
                                throw new Error("Mountpoint exists on path.");
                            else
                                inode = child_file.inode;
                            parent = file;
                            file = this.files[inode];
                            continue;
                        }
                    }
                    if (success === false && i < path_names.length - 1)
                        throw new Error("Cannot create file. '" + path + "' does not exist.");
                    if(success === true && i === path_names.length - 1)
                        throw new Error("File already exists.");
               }
                inode = this.inodes++;
                this.files.push(new VFile(path, data, filetype, inode));
                file.data.push(inode);
            }
            let get_file = function (path, supress_error) {
                let path_names = map_path_names(expand_filepath(path));
                let inode = 0;
                let filesystem = mountpoints[0];
                let file = filesystem.files[0];
                let parent = filesystem.files[0];
                for (let i = 0; i < path_names.length; i++) {
                    let directory = filesystem.files[inode];
                    let success = false;
                    for (let j = 0; j < directory.data.length; j++) {
                        let child_file = filesystem.files[directory.data[j]];
                        if (child_file.filename === path_names[i]) {
                            success = true;
                            if (child_file.mountpoint === true) {
                                for (let i = 0; i < mountpoints.length; i++) {
                                    if (child_file.path === mountpoints[i].path) {
                                        filesystem = mountpoints[i];
                                        inode = 0;
                                    }
                                }
                            } else
                                inode = child_file.inode;
                            parent = file;
                            file = filesystem.files[inode];
                            continue;
                        }
                    }
                    if (success === false) {
                        if (!supress_error) throw new Error("File '" + path + "' does not exist.");
                        break;
                    }
                }
                return {
                    filesystem: filesystem,
                    inode: inode,
                    file: file,
                    parent: parent
                };
            }
            let check_file_exists = function (path) {
                try {
                    get_file(path);
                } catch (e) {
                    return false;
                }
                return true;
            }
            let create_file = function (path, data, filetype) {
                if (check_file_exists(path)) throw new Error("'" + path + "' already exists.");
                let parent_directory = get_file(path, true);
                let filesystem = parent_directory.filesystem;
                let inode = filesystem.inodes++;
                filesystem.files.push(new VFile(path, data, filetype, inode));
                parent_directory.file.data.push(inode);
            }
            // System calls
            function mkdir(path) {
                create_file(path, [], "d");
            }
            function rmdir(path) {
                let file = get_file(path);
                if (file.file.data.length === 0) {
                    file.filesystem.splice(file.inode, 1);
                } else throw new Error("Specified directory is not empty.");
            }
            function fopen(path, mode, data) {
                let file;
                switch (mode) {
                    case "r":
                        file = get_file(path).file;
                        if (file.filetype === "d") throw new Error("Specified file is a directory.");
                        return file.data;
                        break;
                    case "w":
                        if (!check_file_exists(path))
                            create_file(path, "", "-"); // Create file if it does not exist
                        file = get_file(path).file;
                        if (file.filetype === "d") throw new Error("Specified file is a directory.");
                        return file.data = data;
                        break;
                    case "a":
                        if (!check_file_exists(path))
                            create_file(path, "", "-"); // Create file if it does not exist
                        file = get_file(path).file;
                        if (file.filetype === "d") throw new Error("Specified file is a directory.");
                        file.data += data;
                        return file.data;
                        break;
                }
            }
            function unlink(path) {
                let file = get_file(path);
                if (file.file.filetype !== "-") throw new Error("File is not normal.");
                file.parent.data.splice(file.parent.data.indexOf(file.inode), 1);
                file.filesystem.splice(file.inode, 1);
            }
            function stat(path) {
                return get_file(path).file;
            }
            function chmod(path, permissions) {
                get_file(path).file.permissions = permissions;
            }
            function poll(path, handler) {

            }
            function chdir(path) {
                c_process.working_directory = path;
            }
            function readdir(path) {
                let file_descriptor = get_file(path);
                let file = file_descriptor.file;
                let filesystem = file_descriptor.filesystem;
                if (file.filetype !== "d") throw new Error("Specified file is not a directory.");
                let child_files = [];
                for (let i = 0; i < file.data.length; i++) {
                    let child_file = filesystem.files[file.data[i]];
                    child_files.push(child_file.filename);
                }
                return child_files;
            }
            let fs_mount = function (filesystem, path) {
                let file = get_file(path).file;
                if (file.filetype !== "d") throw new Error("Mountpoint must be a directory");
                file.data = filesystem.files[0].data;
                file.is_mountpoint = true;
                filesystem.path = path;
                filesystem.mountid = mountids++;
                mountpoints.push(filesystem);
            }
            function mount(device, path) {
                // if(file.file.filetype !== "b") throw new Error("Specified file is not a block device.");
                fs_mount(get_file(device).file.data, path);
            }
            function umount(path) {
                
            }

            // Logging
            let log = function (message) {
                fopen("/var/kernel/logs", "a", "[" + get_time() + "]: " + message + '\n');
            }

            // Rootfs virtual disk driver
            let tmprootfs = create_fs();
            fs_mount(tmprootfs, "/"); // Mount tmprootfs

            mkdir("/dev");
            mkdir("/sys");
            mkdir("/proc");

            mkdir("/var");
            mkdir("/var/kernel");
            fopen("/var/kernel/logs", "w", "");

            log("Temporary rootfs created.");

            // Root eval
            function root_eval(code) {
                eval(code);
            }

            // System suspension
            let suspended = false;

            // Scheduler
            let threads = [];
            let scheduler = function () {
                if (!suspended) {
                    let start_time = get_time();
                    // Push ready threads into the execution line
                    for (let i = 0; i < processes.length; i++) {
                        let process = processes[i];
                        for (let j = 0; j < process.threads.length; j++) {
                            let thread = process.threads[j];
                            if (thread.dead === true) {
                                process.threads.splice(j, 1);
                                continue;
                            }
                            if (thread.last_execution + thread.sleep_time <= start_time && thread.queued === false) {
                                thread.queued = true;
                                threads.push(thread);
                            }
                        }
                    }

                    while (threads.length > 0) {
                        let time = get_time();
                        if (time > start_time + 100) break; // Scheduler watchdog
                        let thread = threads[0];

                        c_thread = thread;
                        c_process = thread.process;
                        c_user = thread.process.user;
                        thread.queued = false;
                        thread.last_execution = time;
                        try {
                            thread.exec.main();
                        } catch (e) {
                            console.error("Process " + thread.pid + " encountered an error: " + e);
                            thread.process.suspend = true;
                        }
                        threads.splice(0, 1); // Clear the thread from the execution stack
                    }
                    c_thread = {};
                    c_process = {};
                    c_user = 0;
                }
            }

            // Process systemcalls
            function exec(path) {
                // Creates a new process that runs the program at the specified path
                if (!check_file_exists(path)) throw new Error("Cannot execute '" + path + "': path does not exist");
                processes.push(new Process(get_file(path).file.data));
            }
            function sleep(timeout) {
                c_thread.sleep_time = timeout;
            }
            function exit() {
                c_thread.dead = true;
            }

            // Panic
            let panicked = false;
            let panic = function (message) {
                panicked = true;
                console.error("FATAL: Kernel panic -> " + message);
                log("Kernel panicked: " + message);
                alert("System has encountered a fatal error -> '" + message + "'");
            }

            // Main loop
            let main = function () {
                scheduler();
                if (panicked === false)
                    setTimeout(main, 0);
            }
            try {
                log("Starting main loop");
                main();
            } catch (e) {
                panic("Failed to initialize.");
            }

            // Setup init system
            fopen("/bin/init", "w", function() {
                this.main = function() {
                    // Load disk driver

                }
            });

            // Execute init
            log("Running init");
            exec("/bin/init");
        }
    </script>
</head>

<body>
    <canvas width="400" height="400"></canvas>
</body>

</html>